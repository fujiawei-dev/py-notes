---
date: 2020-12-15T12:29:45+08:00  # 创建日期
author: "Rustle Karl"  # 作者

# 文章
title: "Flask 构建 RESTful API"  # 文章标题
# description: "文章描述"
url:  "posts/py/arch/flask/rest"  # 设置网页永久链接
tags: [ "python", "flask" ]  # 标签
series: [ "Flask 学习笔记" ]  # 系列
categories: [ "学习笔记"]  # 分类

# 章节
weight: 20 # 排序优先级
chapter: false  # 设置为章节

index: true  # 是否可以被索引
toc: true  # 是否自动生成目录
draft: false  # 草稿
---

## REST 简介

表征性状态传输（Representational State Transfer，REST）是在客户端和服务端之间传输信息的一种方式。

REST 不是一个严格定义的标准，只是通过对通信方式的若干约束来定义的一种方法论，实现的方式也不是唯一的。这些约束是从多年的尝试和错误中总结而来的，这些经验教训来自其他通信协议，比如远程过程调用（ Remote Procedure Call，RPC ）和简单对象访问协议（ Simple Object Access Protocol，SOAP ）。这些协议之所以逐渐被抛弃，正是因为过于严格的规范、过多的冗余，以及使用它们创建 API 的困难性。人们已经清楚地认识到这些系统的问题所在，而 REST 对通信所做的约束，正是为了避免这些问题再次发生而规定的。

## REST 约束

第 1 个约束，要求客户端和服务端关心的业务是完全分离的。客户端不能处理数据永久存储的任务，服务端也不能处理跟用户界面相关的任何逻辑。

第 2 个约束，要求服务端必须是无状态的。这个条件的含义是，处理请求所需的任何信息都被存储在客户端中，或者被请求本身所携带。无状态服务端的一个例子就是 Flask 中的会话对象。会话对象并没有在服务端储存信息，而是把信息以 cookie 的形式保存在客户端。每个请求都会带上 cookie，服务端对 cookie 进行解析，并判断其有效性是否足以获取所要求的资源，而不会把每个用户的会话信息都保存在服务端。

第 3 个约束，要求服务端提供的所有资源必须有统一的接口形式。这条约束包含了很多不同的部分，如下所述。

- 接口是基于资源的，在我们的例子里也就是对象模型。
- 服务端输出的数据不是服务器上的实际数据，而是包装后的表现形式。例如，对每个请求都不会返回实际的数据库数据，而是返回重新组装的 JSON 格式文本。
- 服务端返回的数据要包含足够的信息，让客户端可以根据这些信息，要求服务端对该数据进行修改。在前面的例子中，返回给客户端的 ID 字段就满足了这条要求。
- API 提供的每项资源，都要以统一的方式进行表达和访问。比如，不能让一个资源以 XML 形式返回，而另一个以 JSON 形式返回；或者一个用原生 TCP，另一个用 HTTP。

最后一个约束是，必须允许中间层的存在。比如，负载均衡器、代理、缓存及其他服务器和服务，都可以透明地存在于 API 服务端和客户端之间，而不会影响返回的结果，就跟它们不存在一样。

当一个系统满足了所有这些约束的要求时，便可以认为它是一个 RESTful 系统。RESTful 系统最常见的形式是由 HTTP 和 JSON 构建的。每种资源都由它们自己的 URL 来定位，并且可以由不同的 HTTP 请求类型来修改。

## HTTP 状态码

在 REST API 中使用正确的 HTTP 状态码，并与响应数据一起返回，是非常重要的。这样客户端不需要对服务端返回的数据进行解析，也能知道在服务端实际发生了什么事。

![image-20201215123852478](https://i.loli.net/2020/12/15/qT8RfzEWQmHpBLM.png)

## Flask Restful

https://flask-restful.readthedocs.io/en/latest/quickstart.html
